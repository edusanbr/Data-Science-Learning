# -*- coding: utf-8 -*-
"""Medalhas - olimpiadas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16YfB23H9nwKXRoqJgAvoZ1L6eXyPwYHq

Predicting medal counts for countries using historical Olympic data with machine learning.
"""

import pandas as pd

#ler dataset
df_times = pd.read_csv('times.csv')
df_times

df_times = df_times[["team","country","year","athletes","age","prev_medals", "medals"]]

#Renomear colunas
df_times.columns = ["time", "pais", "ano", "atletas", "idade", "medalhas_anteriores", "medalhas"]

#Removendo colunas time e pais
df_times_numerico = df_times.drop(columns=["time","pais"], errors="ignore")
df_times_numerico

#gerar matriz de correlação
df_times_numerico.corr()["medalhas"]

import seaborn as sns

sns.lmplot(x="atletas", y="medalhas", data=df_times, fit_reg=True, ci=None)

sns.lmplot(x="idade", y="medalhas", data=df_times, fit_reg=True, ci=None)

df_times.plot.hist(y="medalhas")

#verifica se há valores Nan
df_times[df_times.isnull().any(axis=1)]

# Retira os valores nulos
df_times = df_times.dropna()

import numpy as np
# TRANSFORMAÇÃO LOGARÍTMICA DA VARIÁVEL TARGET (inserida aqui)
df_times["medalhas_log"] = np.log1p(df_times["medalhas"])

#gerar matriz de correlação
df_times_numerico.corr()["medalhas"]

import seaborn as sns

sns.lmplot(x="atletas", y="medalhas", data=df_times, fit_reg=True, ci=None)

sns.lmplot(x="idade", y="medalhas", data=df_times, fit_reg=True, ci=None)

df_times.plot.hist(y="medalhas")

#verifica se há valores Nan
df_times[df_times.isnull().any(axis=1)]

# Retira os valores nulos
df_times = df_times.dropna()

df_times

# Faz o split para treinar o modelo
train = df_times[df_times["ano"] < 2012].copy()
test = df_times[df_times["ano"] >= 2012].copy()

train.shape

test.shape

from sklearn.linear_model import LinearRegression

reg = LinearRegression()

predictors = ["atletas", "medalhas_anteriores"] # define os preditores
target = "medalhas" # Define o eixo Y

# Treina o modelo de regressão usando as variáveis em 'predictors' para prever 'target'
reg.fit(train[predictors], train[target])

# Gera previsões para o conjunto de teste utilizando:
# - Modelo treinado (reg)
# - Variáveis preditoras do conjunto de teste (test[predictors])
predictions = reg.predict(test[predictors])

# Armazena as previsões do modelo no conjunto de teste
# Permitindo análise comparativa com a variável target real
test["predictions"] = predictions

test

# Corrige previsões negativas substituindo-as por zero
test.loc[
    test["predictions"] < 0, "predictions"
] = 0

# Arredonda as previsões para números inteiros
test["predictions"] = test["predictions"].round()

test

from sklearn.metrics import mean_absolute_error

# calcula o mean absolute error
error = mean_absolute_error(test["medalhas"], test["predictions"])

error

df_times.describe()["medalhas"]

test[test["time"] =="USA"]

test[test["time"]=="IND"]

errors = (test["medalhas"] - test["predictions"]).abs()

errors

error_by_team = errors.groupby(test["time"]).mean()

error_by_team

medals_by_team = test["medalhas"].groupby(test["time"]).mean()

error_ratio = error_by_team / medals_by_team

error_ratio

# Remover dados nulos
error_ratio[~pd.isnull(error_ratio)]

import numpy as np
error_ratio = error_ratio[np.isfinite(error_ratio)]
error_ratio

error_ratio.plot.hist()

error_ratio.sort_values()

# Visualizações-chave / importância das variáveis

import matplotlib.pyplot as plt

# Relação entre variáveis
g = sns.pairplot(
    data=df_times_numerico[['atletas', 'medalhas_anteriores', 'medalhas']],
    plot_kws={'alpha': 0.6, 's': 80}
)
g.fig.suptitle("Relação entre Variáveis-Chave", y=1.05)
plt.show()

# Desempenho do modelo
plt.figure(figsize=(10, 6))
ax = sns.scatterplot(
    x='medalhas',
    y='predictions',
    data=test,
    hue='ano',
    palette='coolwarm',
    s=100
)
ax.plot([0, test['medalhas'].max()], [0, test['medalhas'].max()], '--r')
plt.title(f"Previsões vs. Reais (MAE = {error:.1f} medalhas)")
plt.show()

# Importância das variáveis
plt.figure(figsize=(8, 4))
sns.barplot(
    x='Importância',
    y='Variável',
    hue='Variável',  # Corrige o warning
    data=pd.DataFrame({
        'Variável': predictors,
        'Importância': abs(reg.coef_)
    }).sort_values('Importância'),
    palette='rocket',
    legend=False  # Remove legenda redundante
)
plt.title("Impacto das Variáveis no Modelo", pad=20)
plt.xlabel("Coeficiente (valor absoluto)")
plt.ylabel("")
plt.tight_layout()